Word: 
    5 Bytes and a sign (41 bits)
    Can be referrered to with a spec of the form “(L:R)”
    Each instruction is represented by a word, and referred to by the following syntax

Instruction structure: 
    ADDRESS: Bytes (0:2), Address field, the memory address to be used by the instruction 
    INDEX: Bytes (3:3), Used for indexing the instruction 
    MOD: Bytes (4:4), Either used as an operation code modifier or as a field specification
    OPCODE: Bytes (5:5), Which is the opcode that specifies the instruction used

    The address specified by Address + Index is denoted by M

Registers:
    General purpose
    ----------------
    rA: General purpose, holds a word 
    rX: General purpose, holds a word

    Other
    -----
    rJ: Stores positive two-byte jump address
    rI1, rI2, rI3, rI4, rI5, RI6: store two byte value for indexing effective address
    OV: overflow toggle 
    CMP: comparison toggle-can only equal 'E', 'G', or 'L'

I/O:
    Files
    ------
    u1, u2, u3... u7: Magnetic tape
    u8...u15: Disks and drums
    u16: Card reader
    u17: Card writer
    u18: Line printer
    u20: Paper tape

    Stdout:
    ------
    u19

Misc:
    overflow toggle (OV): 1 or 0, on or off
    comparison indicator(CM): can have three possible values, (E,G,L)

Instruction structure:
    ADDRESS: Bytes (0:2), Address field, the memory address to be used by the instruction
    INDEX: Bytes (3:3), Used for indexing the instruction
    MOD: Bytes (4:4), Either used as an operation code modifier or as a field specification
    OPCODE: Bytes (5:5), opcode itself

Instructions:

    Let M(memory) = Address+Index

    Loading
    --------
    LDA: Put the contents of M into rA
    LDX: Put the contents of M into rX
    LDi: Load the contents of M into rIi
    LDAN: Load negative M into rA
    LDXN: Load negative M into rX
    LDiN: Put the negative of the contents of M into rIi
    

    Storing
    -------
    STA: Store the value in rA at memory address M
    STX: Let the value at memory address M = val(rX)
    STi: Store the value in rIi at memory address M 
    STJ: Store J
    STZ: Store zero at memory address M

    Arithmetic
    ----------
    V <- the value at memory address M
    ADD: rA <- rA + V
    SUB: rA <- rA - V
    MUL: Treat rA and rX as a combined 10-byte register, and let RAX <- rA * V
    DIV: rA <- RAX/V, rX <- rAX % V 


    Address transfer operators
    --------------------------

    Quirks:
            MOD is not a modifier, but is treated as part of OPCODE
            The 'M' value is treated as a constant, not as a memory address  

    ENTA: rA <- 'M'
    ENTX: rX <- 'M'
    ENTi: rIi <- 'M'

    ENNA: rA <- -'M'
    ENNX: rX <- -'M'
    ENNi: rIi <- -'M'

    INCA: rA <- rA + 'M'
    INCX: rX <- rX + 'M'
    INCi: rIi <- rIi + 'M'

    DECA: rA <- rA + 'M'
    DECX: rX <- rX + 'M'
    DECi: rIi <- rI + 'M'

    Comparison operators
    -------------------
    All of these set the 'CM' register to either 'E', 'G', or 'L'
    V is the value at address M (memory) plus index
    CMPA: Compare rA with V
    CMPX: Compare rX with V 
    CMPi: Compare rIi with V 

    Jump operators
    --------------

    Instruction overview: Normally, the next instruction is taken from program counter P + 1.
                          After every jump, this is the address stored in rJ unless otherwise specified

    JMP: Unconditional jump- the next instruction is taken from memory cell M
    JSJ: The next instruction is taken from memory cell M, but the value of rJ remains unchanged
    JOV: Jump to the memory address specified by M if the overflow toggle is true
    JNOV: Jump to the memory address specified by M if the overflow toggle is false

    Jumps based on cmp:
    JL, JE, JG, JGE, JNE, JLE: Jump to the memory address specified by M depending on the value in CMP
    
    Jumps based on rA:
    JAN, JAZ, JAP: Jump if A is negative (less than 0), jump if A is zero, jump if A is positive
    JANN, JANZ, JANP: Jump if A is non-negative(>= 0), non-zero, or not positive (<= 0)

    Jumps based on rX
    JXN, JXZ, JXP: Jump if X is negative (< 0), if X is 0, and if x is positive(>0)
    JXNN, JXNZ, JXNP: Jump if x is >= 0, != 0, and <= 0 respectively

    JiN, JiZ, JiP, JiNN, JiNZ, JiNP: same thing but with rIi

    Input/Output
    ------------
    Units:
    Disk, drum, tape: units-I/O File, 100 words space, id 0-15
    card-reader: id 16, 16 words input
    Card punch: id 17, 16 words 
    Line printer: id 18, 24 words
    Typewriter terminal: id 19, 14 words
    Paper tape: id 20, 14 words
    
    id's 16-20 take I/O in mix character encoding
    
    IN: 
    OUT:


 
    Miscellaneous operators:
    ------------------------
    
    1. Shifts
                                        --Quirks--
    Left and right shifts are padded by 0s, circular shifts are padded by the value left out
    M specifies the amount shifted by 
    SLA: Shift rA left
    SRA: Shift rA right
    SLRAX: Treat rA and rX as a combined value and shift left 
    SRAX: Treat rA and rX as a combined value and shift right
    SLC: Shift rAX left circularly
    SRC: Shift rAX right circularly


    2. Move
    MOV: Moves F words from location M to location rI1
            Increases rI1 by F at the end. Seems to basically load words into an index
   
   NOP: Do nothing
   HLT: The machine stops until manually restarted

   
    


Opcodes: 
